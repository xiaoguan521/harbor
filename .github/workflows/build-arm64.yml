name: "Build Harbor ARM64"

on:
  push:
    branches:
      - main
      - release-*
    paths-ignore:
      - 'docs/**'
      - '**.md'
  pull_request:
    branches:
      - main
      - release-*
    paths-ignore:
      - 'docs/**'
      - '**.md'
  workflow_dispatch:
    inputs:
      push_images:
        description: 'Push images to registry'
        required: false
        default: false
        type: boolean

jobs:
  build-arm64-package:
    runs-on: ubuntu-22.04-arm

    steps:
      - name: Checkout Harbor Source Code
        uses: actions/checkout@v4
        with:
          path: src/github.com/goharbor/harbor

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: 1.23.2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        if: github.event.inputs.push_images == 'true'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_PASSWORD }}
      
      - name: Setup Go environment
        run: |
          echo "GOPATH=${{ github.workspace }}" >> $GITHUB_ENV
          echo "${{ github.workspace }}/bin" >> $GITHUB_PATH

      - name: Build ARM64 Package
        id: build_package
        working-directory: src/github.com/goharbor/harbor
        run: |
          set -ex
          
          # --- 准备通用构建参数 ---
          TARGET_BRANCH="$(echo ${GITHUB_REF#refs/heads/})"
          RELEASE_VERSION=$(cat ./VERSION)
          PACKAGE_VERSION="${RELEASE_VERSION}-build.${GITHUB_RUN_NUMBER}-arm64"

          if [[ $TARGET_BRANCH == "main" ]]; then
            ASSETS_VERSION=$PACKAGE_VERSION
          else
            ASSETS_VERSION="${RELEASE_VERSION}-arm64"
          fi

          BASE_TAG=${TARGET_BRANCH#release-}
          if [[ $TARGET_BRANCH == "main" ]]; then
            BASE_TAG=dev
          fi

          # 通用的 Make 参数
          MAKE_FLAGS="GOBUILDTAGS=include_oss \
            BASEIMAGETAG=${BASE_TAG} \
            VERSIONTAG=${ASSETS_VERSION} \
            PKGVERSIONTAG=${PACKAGE_VERSION} \
            TRIVYFLAG=true \
            EXPORTERFLAG=true \
            GOARCH=arm64 \
            BUILDPLATFORM=linux/arm64"

          # --- 核心修正：分两步执行 ---

          # 第 1 步: 强制只构建所有基础镜像。
          # Harbor Makefile 通常有一个 'build-base' 或类似的 target。
          # 我们使用 'build' target 并附带 'BUILD_BASE=true' 和一个假的 'COMPILETAG'
          # 来确保只执行基础镜像的构建，而不进入完整编译阶段。
          echo "--- Step 1: Building base images explicitly for ARM64 ---"
          sudo make build BUILD_BASE=true COMPILETAG=base_only_build ${MAKE_FLAGS}

          # 第 2 步: 构建最终的安装包，并明确告知不要再构建基础镜像。
          # 这会强制 make 使用我们在上一步中已经在本地构建好的 ARM64 基础镜像。
          echo "--- Step 2: Building final packages using local ARM64 base images ---"
          if [[ "${{ github.event.inputs.push_images }}" == "true" ]]; then
            MAKE_FLAGS+=" PUSHBASEIMAGE=true REGISTRYUSER=${{ secrets.DOCKER_HUB_USERNAME }}"
          fi
          
          sudo make package_offline BUILD_BASE=false ${MAKE_FLAGS}
          sudo make package_online BUILD_BASE=false ${MAKE_FLAGS}

          # --- 产出物处理 ---
          OFFLINE_BUNDLE=$(ls harbor-offline-installer-*.tgz)
          ONLINE_BUNDLE=$(ls harbor-online-installer-*.tgz)
          
          echo "offline_bundle_path=$PWD/$OFFLINE_BUNDLE" >> $GITHUB_OUTPUT
          echo "online_bundle_path=$PWD/$ONLINE_BUNDLE" >> $GITHUB_OUTPUT
          echo "assets_version=${ASSETS_VERSION}" >> $GITHUB_OUTPUT

      # ... (后续的 upload 和 push 步骤保持不变) ...
      - name: Upload build artifacts to GitHub
        uses: actions/upload-artifact@v4
        with:
          name: harbor-arm64-packages
          path: |
            ${{ steps.build_package.outputs.offline_bundle_path }}
            ${{ steps.build_package.outputs.online_bundle_path }}
          retention-days: 7

      - name: Push ARM64 Docker Images
        if: github.event.inputs.push_images == 'true'
        working-directory: src/github.com/goharbor/harbor
        run: |
          ASSETS_VERSION="${{ steps.build_package.outputs.assets_version }}"
          OFFLINE_BUNDLE_PATH="${{ steps.build_package.outputs.offline_bundle_path }}"
          
          tar -xvf "${OFFLINE_BUNDLE_PATH}"
          docker load -i harbor/harbor.${ASSETS_VERSION}.tar
          
          docker images "goharbor/*:${ASSETS_VERSION}" --format "{{.Repository}}:{{.Tag}}" | while read -r image; do
            echo "Pushing ${image}"
            docker push "${image}"
          done