name: "Build Harbor ARM64"

on:
  push:
    branches:
      - main
      - release-*
    paths-ignore:
      - 'docs/**'
      - '**.md'
  pull_request:
    branches:
      - main
      - release-*
    paths-ignore:
      - 'docs/**'
      - '**.md'
  workflow_dispatch:
    inputs:
      push_images:
        description: 'Push images to registry'
        required: false
        default: false
        type: boolean

jobs:
  build-arm64-package:
    runs-on: ubuntu-22.04-arm

    steps:
      - name: Checkout Harbor Source Code
        uses: actions/checkout@v4
        with:
          path: src/github.com/goharbor/harbor

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: 1.23.2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        if: github.event.inputs.push_images == 'true'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_PASSWORD }}
      
      - name: Setup Go environment
        run: |
          echo "GOPATH=${{ github.workspace }}" >> $GITHUB_ENV
          echo "${{ github.workspace }}/bin" >> $GITHUB_PATH

      # --- 终极补丁脚本：一次性修复所有已知问题 ---
      - name: Find and Patch all Dockerfiles for ARM64
        working-directory: src/github.com/goharbor/harbor
        run: |
          set -ex
          echo ">>> Stage 1: Globally patching all Dockerfiles to use a generic ARM64 base..."
          TARGET_FILES=$(grep -rl 'FROM \${harbor_base_namespace}/.*-base:\${harbor_base_image_version}' ./make)
          
          for dockerfile in $TARGET_FILES; do
            echo "Patching ${dockerfile} with generic base..."
            sed -i 's|FROM ${harbor_base_namespace}/.*-base:${harbor_base_image_version}|FROM photon:4.0|g' "$dockerfile"
          done

          echo "\n>>> Stage 2: Applying specific patches for individual components..."
          DB_DOCKERFILE="make/photon/db/Dockerfile"
          PREPARE_DOCKERFILE="make/photon/prepare/Dockerfile"
          LOG_DOCKERFILE="make/photon/log/Dockerfile"
          REDIS_DOCKERFILE="make/photon/redis/Dockerfile"

          echo "Applying 'postgres' patch to ${DB_DOCKERFILE}..."
          sed -i 's|FROM photon:4.0|FROM postgres:14-alpine|g' "${DB_DOCKERFILE}"

          echo "Applying 'redis' patch to ${REDIS_DOCKERFILE}..."
          sed -i 's|FROM photon:4.0|FROM redis:7-alpine|g' "${REDIS_DOCKERFILE}"

          echo "Applying 'pipenv' patch to ${PREPARE_DOCKERFILE}..."
          awk '/COPY make\/photon\/prepare\/Pipfile.lock/ {
            print "RUN tdnf -y install python3 python3-pip && pip3 install pipenv"
          } 1' "${PREPARE_DOCKERFILE}" > "${PREPARE_DOCKERFILE}.tmp" && mv "${PREPARE_DOCKERFILE}.tmp" "${PREPARE_DOCKERFILE}"
          
          echo "Applying 'logrotate' patch to ${LOG_DOCKERFILE}..."
          sed -i '/\/etc\/cron.daily\/logrotate/c\RUN tdnf install -y logrotate && rm -f /etc/cron.daily/logrotate' "${LOG_DOCKERFILE}"

          echo "\n>>> Stage 3: Globally creating 'harbor' user and group where needed..."
          for dockerfile in $TARGET_FILES; do
            if grep -q "FROM photon:4.0" "$dockerfile"; then
              echo "Adding user/group creation tools and 'harbor' user/group to ${dockerfile}..."
              awk '/FROM photon:4.0/ {
                print;
                print "RUN tdnf install -y shadow && groupadd --system --gid 10000 harbor && useradd --system --uid 10000 --gid harbor harbor && mkdir -p /home/harbor";
                next
              }1' "$dockerfile" > "$dockerfile.tmp" && mv "$dockerfile.tmp" "$dockerfile"
            fi
          done

      - name: Build ARM64 Package
        id: build_package
        working-directory: src/github.com/goharbor/harbor
        run: |
          set -ex
          
          # 步骤 1: 读取官方版本号, 这是所有内部镜像的统一标签
          RELEASE_VERSION=$(cat ./VERSION)
          
          # 步骤 2: 定义最终产物的文件名
          PACKAGE_FILENAME_VERSION="${RELEASE_VERSION}-build.${GITHUB_RUN_NUMBER}-arm64"

          # 步骤 3: 构造 make 命令参数, 确保所有内部标签都使用官方版本号
          MAKE_FLAGS="BUILD_BASE=true \
            GOBUILDTAGS=include_oss \
            BASEIMAGETAG=${RELEASE_VERSION} \
            VERSIONTAG=${RELEASE_VERSION} \
            PKGVERSIONTAG=${RELEASE_VERSION} \
            TRIVYFLAG=true \
            EXPORTERFLAG=true \
            GOARCH=arm64 \
            BUILDPLATFORM=linux/arm64"
          
          if [[ "${{ github.event.inputs.push_images }}" == "true" ]]; then
            MAKE_FLAGS+=" PUSHBASEIMAGE=true REGISTRYUSER=${{ secrets.DOCKER_HUB_USERNAME }}"
          fi

          # 步骤 4: 执行构建
          sudo make package_offline $MAKE_FLAGS
          sudo make package_online $MAKE_FLAGS
          
          # 步骤 5: 将 make 生成的、使用官方版本号命名的包, 重命名为我们需要的、带详细信息的文件名
          mv "harbor-offline-installer-${RELEASE_VERSION}.tgz" "harbor-offline-installer-${PACKAGE_FILENAME_VERSION}.tgz"
          mv "harbor-online-installer-${RELEASE_VERSION}.tgz" "harbor-online-installer-${PACKAGE_FILENAME_VERSION}.tgz"

          OFFLINE_BUNDLE="harbor-offline-installer-${PACKAGE_FILENAME_VERSION}.tgz"
          ONLINE_BUNDLE="harbor-online-installer-${PACKAGE_FILENAME_VERSION}.tgz"
          
          echo "offline_bundle_path=$PWD/$OFFLINE_BUNDLE" >> $GITHUB_OUTPUT
          echo "online_bundle_path=$PWD/$ONLINE_BUNDLE" >> $GITHUB_OUTPUT
          # 用于推送镜像的资产版本, 也必须使用官方版本号
          echo "assets_version=${RELEASE_VERSION}" >> $GITHUB_OUTPUT

      - name: Upload build artifacts to GitHub
        uses: actions/upload-artifact@v4
        with:
          name: harbor-arm64-packages
          path: |
            ${{ steps.build_package.outputs.offline_bundle_path }}
            ${{ steps.build_package.outputs.online_bundle_path }}
          retention-days: 7

      - name: Push ARM64 Docker Images
        if: github.event.inputs.push_images == 'true'
        working-directory: src/github.com/goharbor/harbor
        run: |
          ASSETS_VERSION="${{ steps.build_package.outputs.assets_version }}"
          OFFLINE_BUNDLE_PATH="${{ steps.build_package.outputs.offline_bundle_path }}"
          
          tar -xvf "${OFFLINE_BUNDLE_PATH}"
          docker load -i "harbor/harbor.${ASSETS_VERSION}.tar"
          
          docker images "goharbor/*:${ASSETS_VERSION}" --format "{{.Repository}}:{{.Tag}}" | while read -r image; do
            echo "Pushing ${image}"
            docker push "${image}"
          done